---
title: C26414
ms.date: 11/15/2017
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: c3e166484eb0ec07c6ec7bcc00d7ec3df76c4e31
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/19/2018
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
"Spostare, copiare, riassegnare o reimpostare un puntatore intelligente locale."

**Linee guida dei componenti di base di C++**: R.5: preferiscono gli oggetti con ambiti, non heap-allocare inutilmente

Puntatori intelligenti sono utili per la gestione dinamica delle risorse, ma non sono sempre necessari. Ad esempio, la creazione di un buffer locale dinamico può essere facilmente (talvolta terminare più efficiente) gestiti dai contenitori standard. Per i singoli oggetti potrebbe essere necessario eseguire affatto l'allocazione dinamica (ad esempio, se tali oggetti non sopravvivono mai la funzione di creazione) e possono essere sostituiti con le variabili locali. I puntatori intelligenti sono utili quando scenario richiede la modifica di proprietà, ad esempio la riassegnazione di una risorsa dinamica più volte o in più percorsi. Ciò include anche i casi in cui le risorse vengono ottenute da codice esterno e puntatori intelligenti vengono utilizzati per estendere la durata della risorsa.

## <a name="remarks"></a>Note
 -  Oltre ai modelli std::shared_pointer e std::unique_pointer standard, questo controllo riconosce i tipi definiti dall'utente che probabilmente sono destinati a essere puntatori intelligenti. Tali tipi devono definire le operazioni seguenti:
-  di overload dereferenziazione oppure gli operatori di accesso di membro, che sono pubblici e non contrassegnato come eliminato;
-  distruttore pubblico che non viene eliminato né impostate come predefinito. Sono inclusi i distruttori che sono definiti esplicitamente come vuoto.
-  Il tipo Microsoft::WRL::ComPtr si comporta come un puntatore condiviso, ma viene spesso utilizzato in scenari molto specifici che interessa la gestione della durata COM. Per evitare il rumore eccessivo questo tipo è filtrato.
-  Vengono ricercate allocazioni esplicite di locale assegnate per i puntatori intelligenti per identificare se le variabili con ambite Impossibile word come un'alternativa. Oltre alle chiamate dirette all'operatore new, funzioni speciali come std::make_unique e std::make_shared inoltre vengono interpretate come allocazioni dirette.
-
## <a name="example"></a>Esempio
buffer dinamico

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Esempio
buffer dinamico: sostituito dal contenitore

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
